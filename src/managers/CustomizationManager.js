const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder, ModalBuilder, TextInputBuilder, TextInputStyle } = require('discord.js');
const fs = require('fs').promises;
const path = require('path');

class CustomizationManager {
	constructor(client) {
		this.client = client;
		this.configPath = path.join(__dirname, '../../config.json');
		this.themesPath = path.join(__dirname, '../../themes');
		this.templatesPath = path.join(__dirname, '../../templates');

		this.defaultThemes = {
			default: {
				name: 'D√©faut',
				colors: {
					primary: '#00ff00',
					secondary: '#0099ff',
					success: '#00ff00',
					warning: '#ffaa00',
					error: '#ff0000',
				},
				emojis: {
					stats: 'üìä',
					members: 'üë•',
					messages: 'üí¨',
					voice: 'üîä',
					success: '‚úÖ',
					error: '‚ùå',
					warning: '‚ö†Ô∏è',
				},
			},
			dark: {
				name: 'Sombre',
				colors: {
					primary: '#2f3136',
					secondary: '#36393f',
					success: '#43b581',
					warning: '#faa61a',
					error: '#f04747',
				},
				emojis: {
					stats: 'üìà',
					members: 'üë§',
					messages: 'üí≠',
					voice: 'üé§',
					success: 'üü¢',
					error: 'üî¥',
					warning: 'üü°',
				},
			},
			light: {
				name: 'Clair',
				colors: {
					primary: '#ffffff',
					secondary: '#f6f6f6',
					success: '#28a745',
					warning: '#ffc107',
					error: '#dc3545',
				},
				emojis: {
					stats: 'üìä',
					members: 'üë•',
					messages: 'üí¨',
					voice: 'üîä',
					success: '‚úÖ',
					error: '‚ùå',
					warning: '‚ö†Ô∏è',
				},
			},
			corporate: {
				name: 'Entreprise',
				colors: {
					primary: '#1f4e79',
					secondary: '#2e5984',
					success: '#70ad47',
					warning: '#d9a441',
					error: '#c5504b',
				},
				emojis: {
					stats: 'üìã',
					members: 'üëî',
					messages: 'üìù',
					voice: 'üìû',
					success: '‚úîÔ∏è',
					error: '‚úñÔ∏è',
					warning: '‚ö°',
				},
			},
		};

		this.initializeCustomization();
	}

	async initializeCustomization() {
		try {
			// Cr√©er les dossiers n√©cessaires
			await fs.mkdir(this.themesPath, { recursive: true });
			await fs.mkdir(this.templatesPath, { recursive: true });

			// Initialiser les th√®mes par d√©faut
			await this.initializeDefaultThemes();

			console.log('üé® CustomizationManager initialis√©');
		}
		catch (error) {
			console.error('‚ùå Erreur lors de l\'initialisation du CustomizationManager:', error);
		}
	}

	async initializeDefaultThemes() {
		for (const [themeId, theme] of Object.entries(this.defaultThemes)) {
			const themePath = path.join(this.themesPath, `${themeId}.json`);

			try {
				await fs.access(themePath);
			}
			catch {
				// Le fichier n'existe pas, le cr√©er
				await fs.writeFile(themePath, JSON.stringify(theme, null, 2));
			}
		}
	}

	async showCustomizationMenu(interaction) {
		try {
			const config = JSON.parse(await fs.readFile(this.configPath, 'utf8'));
			const currentTheme = await this.getCurrentTheme();

			const embed = new EmbedBuilder()
				.setTitle('üé® Personnalisation du Bot')
				.setDescription('Personnalisez l\'apparence et le comportement du bot')
				.setColor(currentTheme.colors.primary)
				.addFields([
					{
						name: 'üé® Th√®me actuel',
						value: `**${currentTheme.name}**\nCouleur principale: ${currentTheme.colors.primary}`,
						inline: true,
					},
					{
						name: '‚öôÔ∏è Options disponibles',
						value: [
							'üé® Changer de th√®me',
							'üîß Modifier les couleurs',
							'üòÄ Personnaliser les emojis',
							'üìù Cr√©er un mod√®le',
							'üìã G√©rer les mod√®les',
						].join('\n'),
						inline: true,
					},
				])
				.setTimestamp();

			const components = this.createCustomizationComponents();

			await interaction.reply({
				embeds: [embed],
				components: components,
				
			});

		}
		catch (error) {
			console.error('‚ùå Erreur lors de l\'affichage du menu de personnalisation:', error);
			throw error;
		}
	}

	createCustomizationComponents() {
		const selectMenu = new StringSelectMenuBuilder()
			.setCustomId('customization_select')
			.setPlaceholder('S√©lectionner une option de personnalisation')
			.addOptions([
				{
					label: 'Changer de th√®me',
					description: 'S√©lectionner un th√®me pr√©d√©fini',
					value: 'theme',
					emoji: 'üé®',
				},
				{
					label: 'Couleurs personnalis√©es',
					description: 'Modifier les couleurs individuellement',
					value: 'colors',
					emoji: 'üåà',
				},
				{
					label: 'Emojis personnalis√©s',
					description: 'Changer les emojis utilis√©s',
					value: 'emojis',
					emoji: 'üòÄ',
				},
				{
					label: 'Cr√©er un mod√®le',
					description: 'Cr√©er un nouveau mod√®le de rapport',
					value: 'template',
					emoji: 'üìù',
				},
				{
					label: 'G√©rer les mod√®les',
					description: 'Modifier ou supprimer des mod√®les',
					value: 'manage_templates',
					emoji: 'üìã',
				},
			]);

		const buttons = new ActionRowBuilder()
			.addComponents(
				new ButtonBuilder()
					.setCustomId('customization_preview')
					.setLabel('Aper√ßu')
					.setStyle(ButtonStyle.Primary)
					.setEmoji('üëÅÔ∏è'),
				new ButtonBuilder()
					.setCustomId('customization_reset')
					.setLabel('R√©initialiser')
					.setStyle(ButtonStyle.Danger)
					.setEmoji('üîÑ'),
				new ButtonBuilder()
					.setCustomId('customization_export')
					.setLabel('Exporter')
					.setStyle(ButtonStyle.Secondary)
					.setEmoji('üì§'),
				new ButtonBuilder()
					.setCustomId('customization_import')
					.setLabel('Importer')
					.setStyle(ButtonStyle.Secondary)
					.setEmoji('üì•'),
			);

		return [
			new ActionRowBuilder().addComponents(selectMenu),
			buttons,
		];
	}

	async showThemeSelector(interaction) {
		try {
			const themes = await this.getAllThemes();
			const currentTheme = await this.getCurrentTheme();

			const embed = new EmbedBuilder()
				.setTitle('üé® S√©lection de th√®me')
				.setDescription('Choisissez un th√®me pour personnaliser l\'apparence du bot')
				.setColor(currentTheme.colors.primary)
				.setTimestamp();

			// Ajouter un aper√ßu de chaque th√®me
			for (const [themeId, theme] of Object.entries(themes)) {
				embed.addFields([
					{
						name: `${themeId === 'current' ? '‚úÖ ' : ''}${theme.name}`,
						value: [
							`üé® Couleur: ${theme.colors.primary}`,
							`${theme.emojis.stats} Stats | ${theme.emojis.members} Membres | ${theme.emojis.messages} Messages`,
						].join('\n'),
						inline: true,
					},
				]);
			}

			const selectMenu = new StringSelectMenuBuilder()
				.setCustomId('theme_select')
				.setPlaceholder('S√©lectionner un th√®me')
				.addOptions(
					Object.entries(themes).map(([themeId, theme]) => ({
						label: theme.name,
						description: `Couleur principale: ${theme.colors.primary}`,
						value: themeId,
						emoji: 'üé®',
					})),
				);

			const components = [
				new ActionRowBuilder().addComponents(selectMenu),
				new ActionRowBuilder().addComponents(
					new ButtonBuilder()
						.setCustomId('theme_create')
						.setLabel('Cr√©er un th√®me')
						.setStyle(ButtonStyle.Success)
						.setEmoji('‚ûï'),
					new ButtonBuilder()
						.setCustomId('customization_back')
						.setLabel('Retour')
						.setStyle(ButtonStyle.Secondary)
						.setEmoji('‚¨ÖÔ∏è'),
				),
			];

			await interaction.update({
				embeds: [embed],
				components: components,
			});

		}
		catch (error) {
			console.error('‚ùå Erreur lors de l\'affichage du s√©lecteur de th√®me:', error);
			throw error;
		}
	}

	async showColorCustomizer(interaction) {
		try {
			const currentTheme = await this.getCurrentTheme();

			const embed = new EmbedBuilder()
				.setTitle('üåà Personnalisation des couleurs')
				.setDescription('Modifiez les couleurs utilis√©es par le bot')
				.setColor(currentTheme.colors.primary)
				.addFields([
					{
						name: 'üé® Couleurs actuelles',
						value: [
							`**Principale:** ${currentTheme.colors.primary}`,
							`**Secondaire:** ${currentTheme.colors.secondary}`,
							`**Succ√®s:** ${currentTheme.colors.success}`,
							`**Avertissement:** ${currentTheme.colors.warning}`,
							`**Erreur:** ${currentTheme.colors.error}`,
						].join('\n'),
						inline: false,
					},
				])
				.setTimestamp();

			const selectMenu = new StringSelectMenuBuilder()
				.setCustomId('color_select')
				.setPlaceholder('S√©lectionner une couleur √† modifier')
				.addOptions([
					{
						label: 'Couleur principale',
						description: 'Couleur principale des embeds',
						value: 'primary',
						emoji: 'üé®',
					},
					{
						label: 'Couleur secondaire',
						description: 'Couleur secondaire des √©l√©ments',
						value: 'secondary',
						emoji: 'üé≠',
					},
					{
						label: 'Couleur de succ√®s',
						description: 'Couleur pour les messages de succ√®s',
						value: 'success',
						emoji: '‚úÖ',
					},
					{
						label: 'Couleur d\'avertissement',
						description: 'Couleur pour les avertissements',
						value: 'warning',
						emoji: '‚ö†Ô∏è',
					},
					{
						label: 'Couleur d\'erreur',
						description: 'Couleur pour les messages d\'erreur',
						value: 'error',
						emoji: '‚ùå',
					},
				]);

			const components = [
				new ActionRowBuilder().addComponents(selectMenu),
				new ActionRowBuilder().addComponents(
					new ButtonBuilder()
						.setCustomId('color_preset')
						.setLabel('Couleurs pr√©d√©finies')
						.setStyle(ButtonStyle.Primary)
						.setEmoji('üé®'),
					new ButtonBuilder()
						.setCustomId('customization_back')
						.setLabel('Retour')
						.setStyle(ButtonStyle.Secondary)
						.setEmoji('‚¨ÖÔ∏è'),
				),
			];

			await interaction.update({
				embeds: [embed],
				components: components,
			});

		}
		catch (error) {
			console.error('‚ùå Erreur lors de l\'affichage du personnalisateur de couleurs:', error);
			throw error;
		}
	}

	async showEmojiCustomizer(interaction) {
		try {
			const currentTheme = await this.getCurrentTheme();

			const embed = new EmbedBuilder()
				.setTitle('üòÄ Personnalisation des emojis')
				.setDescription('Modifiez les emojis utilis√©s par le bot')
				.setColor(currentTheme.colors.primary)
				.addFields([
					{
						name: 'üòÄ Emojis actuels',
						value: [
							`**Stats:** ${currentTheme.emojis.stats}`,
							`**Membres:** ${currentTheme.emojis.members}`,
							`**Messages:** ${currentTheme.emojis.messages}`,
							`**Vocal:** ${currentTheme.emojis.voice}`,
							`**Succ√®s:** ${currentTheme.emojis.success}`,
							`**Erreur:** ${currentTheme.emojis.error}`,
							`**Avertissement:** ${currentTheme.emojis.warning}`,
						].join('\n'),
						inline: false,
					},
				])
				.setTimestamp();

			const selectMenu = new StringSelectMenuBuilder()
				.setCustomId('emoji_select')
				.setPlaceholder('S√©lectionner un emoji √† modifier')
				.addOptions([
					{
						label: 'Emoji Stats',
						description: 'Emoji pour les statistiques',
						value: 'stats',
						emoji: currentTheme.emojis.stats,
					},
					{
						label: 'Emoji Membres',
						description: 'Emoji pour les membres',
						value: 'members',
						emoji: currentTheme.emojis.members,
					},
					{
						label: 'Emoji Messages',
						description: 'Emoji pour les messages',
						value: 'messages',
						emoji: currentTheme.emojis.messages,
					},
					{
						label: 'Emoji Vocal',
						description: 'Emoji pour l\'activit√© vocale',
						value: 'voice',
						emoji: currentTheme.emojis.voice,
					},
					{
						label: 'Emoji Succ√®s',
						description: 'Emoji pour les succ√®s',
						value: 'success',
						emoji: currentTheme.emojis.success,
					},
					{
						label: 'Emoji Erreur',
						description: 'Emoji pour les erreurs',
						value: 'error',
						emoji: currentTheme.emojis.error,
					},
					{
						label: 'Emoji Avertissement',
						description: 'Emoji pour les avertissements',
						value: 'warning',
						emoji: currentTheme.emojis.warning,
					},
				]);

			const components = [
				new ActionRowBuilder().addComponents(selectMenu),
				new ActionRowBuilder().addComponents(
					new ButtonBuilder()
						.setCustomId('emoji_reset')
						.setLabel('R√©initialiser')
						.setStyle(ButtonStyle.Danger)
						.setEmoji('üîÑ'),
					new ButtonBuilder()
						.setCustomId('customization_back')
						.setLabel('Retour')
						.setStyle(ButtonStyle.Secondary)
						.setEmoji('‚¨ÖÔ∏è'),
				),
			];

			await interaction.update({
				embeds: [embed],
				components: components,
			});

		}
		catch (error) {
			console.error('‚ùå Erreur lors de l\'affichage du personnalisateur d\'emojis:', error);
			throw error;
		}
	}

	async applyTheme(themeId) {
		try {
			const theme = await this.getTheme(themeId);
			if (!theme) {
				throw new Error('Th√®me non trouv√©');
			}

			// Lire la configuration actuelle
			const config = JSON.parse(await fs.readFile(this.configPath, 'utf8'));

			// Appliquer le th√®me
			config.theme = themeId;
			config.embedColor = theme.colors.primary;
			config.customization = {
				colors: theme.colors,
				emojis: theme.emojis,
			};

			// Sauvegarder la configuration
			await fs.writeFile(this.configPath, JSON.stringify(config, null, 2));

			console.log(`üé® Th√®me "${theme.name}" appliqu√© avec succ√®s`);
			return true;

		}
		catch (error) {
			console.error('‚ùå Erreur lors de l\'application du th√®me:', error);
			return false;
		}
	}

	async updateColor(colorType, colorValue) {
		try {
			const config = JSON.parse(await fs.readFile(this.configPath, 'utf8'));

			if (!config.customization) {
				config.customization = { colors: {}, emojis: {} };
			}

			config.customization.colors[colorType] = colorValue;

			// Si c'est la couleur principale, mettre √† jour embedColor aussi
			if (colorType === 'primary') {
				config.embedColor = colorValue;
			}

			await fs.writeFile(this.configPath, JSON.stringify(config, null, 2));

			console.log(`üé® Couleur ${colorType} mise √† jour: ${colorValue}`);
			return true;

		}
		catch (error) {
			console.error('‚ùå Erreur lors de la mise √† jour de la couleur:', error);
			return false;
		}
	}

	async updateEmoji(emojiType, emojiValue) {
		try {
			const config = JSON.parse(await fs.readFile(this.configPath, 'utf8'));

			if (!config.customization) {
				config.customization = { colors: {}, emojis: {} };
			}

			config.customization.emojis[emojiType] = emojiValue;

			await fs.writeFile(this.configPath, JSON.stringify(config, null, 2));

			console.log(`üòÄ Emoji ${emojiType} mis √† jour: ${emojiValue}`);
			return true;

		}
		catch (error) {
			console.error('‚ùå Erreur lors de la mise √† jour de l\'emoji:', error);
			return false;
		}
	}

	async createCustomTheme(name, colors, emojis) {
		try {
			const themeId = name.toLowerCase().replace(/\s+/g, '_');
			const theme = {
				name: name,
				colors: colors,
				emojis: emojis,
				custom: true,
				created: new Date().toISOString(),
			};

			const themePath = path.join(this.themesPath, `${themeId}.json`);
			await fs.writeFile(themePath, JSON.stringify(theme, null, 2));

			console.log(`üé® Th√®me personnalis√© "${name}" cr√©√©`);
			return themeId;

		}
		catch (error) {
			console.error('‚ùå Erreur lors de la cr√©ation du th√®me personnalis√©:', error);
			return null;
		}
	}

	async getCurrentTheme() {
		try {
			const config = JSON.parse(await fs.readFile(this.configPath, 'utf8'));

			if (config.customization) {
				return {
					name: 'Personnalis√©',
					colors: config.customization.colors || this.defaultThemes.default.colors,
					emojis: config.customization.emojis || this.defaultThemes.default.emojis,
				};
			}

			const themeId = config.theme || 'default';
			return await this.getTheme(themeId) || this.defaultThemes.default;

		}
		catch (error) {
			console.error('‚ùå Erreur lors de la r√©cup√©ration du th√®me actuel:', error);
			return this.defaultThemes.default;
		}
	}

	async getTheme(themeId) {
		try {
			if (this.defaultThemes[themeId]) {
				return this.defaultThemes[themeId];
			}

			const themePath = path.join(this.themesPath, `${themeId}.json`);
			const themeData = await fs.readFile(themePath, 'utf8');
			return JSON.parse(themeData);

		}
		catch (error) {
			return null;
		}
	}

	async getAllThemes() {
		try {
			const themes = { ...this.defaultThemes };

			// Ajouter les th√®mes personnalis√©s
			const themeFiles = await fs.readdir(this.themesPath);

			for (const file of themeFiles) {
				if (file.endsWith('.json')) {
					const themeId = file.replace('.json', '');
					if (!themes[themeId]) {
						const theme = await this.getTheme(themeId);
						if (theme) {
							themes[themeId] = theme;
						}
					}
				}
			}

			return themes;

		}
		catch (error) {
			console.error('‚ùå Erreur lors de la r√©cup√©ration des th√®mes:', error);
			return this.defaultThemes;
		}
	}

	async exportTheme(themeId) {
		try {
			const theme = await this.getTheme(themeId);
			if (!theme) {
				throw new Error('Th√®me non trouv√©');
			}

			const exportData = {
				...theme,
				exported: new Date().toISOString(),
				version: '1.0.0',
			};

			return JSON.stringify(exportData, null, 2);

		}
		catch (error) {
			console.error('‚ùå Erreur lors de l\'export du th√®me:', error);
			return null;
		}
	}

	async importTheme(themeData) {
		try {
			const theme = JSON.parse(themeData);

			// Valider la structure du th√®me
			if (!theme.name || !theme.colors || !theme.emojis) {
				throw new Error('Structure de th√®me invalide');
			}

			const themeId = theme.name.toLowerCase().replace(/\s+/g, '_');
			const themePath = path.join(this.themesPath, `${themeId}.json`);

			theme.imported = new Date().toISOString();
			await fs.writeFile(themePath, JSON.stringify(theme, null, 2));

			console.log(`üì• Th√®me "${theme.name}" import√© avec succ√®s`);
			return themeId;

		}
		catch (error) {
			console.error('‚ùå Erreur lors de l\'import du th√®me:', error);
			return null;
		}
	}

	async resetCustomization() {
		try {
			const config = JSON.parse(await fs.readFile(this.configPath, 'utf8'));

			// Supprimer la personnalisation
			delete config.customization;
			config.theme = 'default';
			config.embedColor = this.defaultThemes.default.colors.primary;

			await fs.writeFile(this.configPath, JSON.stringify(config, null, 2));

			console.log('üîÑ Personnalisation r√©initialis√©e');
			return true;

		}
		catch (error) {
			console.error('‚ùå Erreur lors de la r√©initialisation:', error);
			return false;
		}
	}

	createColorModal(colorType) {
		const modal = new ModalBuilder()
			.setCustomId(`color_modal_${colorType}`)
			.setTitle(`Modifier la couleur ${colorType}`);

		const colorInput = new TextInputBuilder()
			.setCustomId('color_value')
			.setLabel('Code couleur hexad√©cimal')
			.setStyle(TextInputStyle.Short)
			.setPlaceholder('#00ff00')
			.setRequired(true)
			.setMaxLength(7)
			.setMinLength(7);

		modal.addComponents(new ActionRowBuilder().addComponents(colorInput));
		return modal;
	}

	createEmojiModal(emojiType) {
		const modal = new ModalBuilder()
			.setCustomId(`emoji_modal_${emojiType}`)
			.setTitle(`Modifier l'emoji ${emojiType}`);

		const emojiInput = new TextInputBuilder()
			.setCustomId('emoji_value')
			.setLabel('Emoji ou code emoji')
			.setStyle(TextInputStyle.Short)
			.setPlaceholder('üìä ou :chart_with_upwards_trend:')
			.setRequired(true)
			.setMaxLength(50);

		modal.addComponents(new ActionRowBuilder().addComponents(emojiInput));
		return modal;
	}

	validateColor(color) {
		const hexRegex = /^#[0-9A-Fa-f]{6}$/;
		return hexRegex.test(color);
	}

	validateEmoji(emoji) {
		// Validation basique pour les emojis
		return emoji.length > 0 && emoji.length <= 50;
	}
}

module.exports = CustomizationManager;